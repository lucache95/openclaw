---
phase: 19-gateway-connection
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - ui/src/ui/app-gateway.ts
  - ui/src/ui/app-render.ts
  - ui/src/ui/state/chat.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket auto-reconnects after network interruption with exponential backoff (no manual refresh needed)"
    - "UI components reactively update when new messages arrive via @lit-labs/signals state layer"
    - "Connection status is visible to the user (connected, reconnecting, disconnected)"
  artifacts:
    - path: "ui/src/ui/app-gateway.ts"
      provides: "Signal-wired gateway connection with three-state status"
      contains: "setConnectionStatus"
    - path: "ui/src/ui/state/chat.ts"
      provides: "Shared chat state signals for reactive message updates"
      exports: ["chatMessages", "chatStream", "pushChatMessage"]
    - path: "ui/src/ui/app-render.ts"
      provides: "Connection indicator rendered in the chat view topbar"
      contains: "connection-indicator"
  key_links:
    - from: "ui/src/ui/app-gateway.ts"
      to: "ui/src/ui/state/connection.ts"
      via: "setConnectionStatus calls"
      pattern: "setConnectionStatus\\("
    - from: "ui/src/ui/app-render.ts"
      to: "ui/src/ui/components/connection-indicator.ts"
      via: "HTML tag usage"
      pattern: "<connection-indicator"
    - from: "ui/src/ui/app-gateway.ts"
      to: "ui/src/ui/state/chat.ts"
      via: "signal updates on chat events"
      pattern: "chatMessages|chatStream"
---

<objective>
Wire connection signals into the gateway lifecycle and render the connection indicator in the UI. Create chat state signals for reactive message delivery.

Purpose: Complete the integration so that (1) the gateway connection manager drives the shared connection signal through all three states, (2) the connection indicator appears in the chat view, and (3) chat messages flow through signals for reactive cross-component updates.
Output: Fully wired gateway -> signals -> UI pipeline with visible connection status.
</objective>

<execution_context>
@/Users/lucassenechal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lucassenechal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-gateway-connection/19-01-SUMMARY.md

Key files:
@ui/src/ui/app-gateway.ts — connectGateway() with onHello/onClose callbacks (modify)
@ui/src/ui/app-render.ts — renderApp function (modify to add indicator)
@ui/src/ui/gateway.ts — GatewayBrowserClient (read-only, already has auto-reconnect)
@ui/src/ui/state/connection.ts — connection signals from Plan 01
@ui/src/ui/components/connection-indicator.ts — indicator component from Plan 01
@ui/src/ui/views/chat.ts — chat view (read-only, understand structure)
@ui/src/ui/app.ts — main app component (read-only, understand @state pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire connection signals into gateway lifecycle</name>
  <files>ui/src/ui/app-gateway.ts</files>
  <action>
Modify `ui/src/ui/app-gateway.ts` to drive the connection status signal through all three states:

1. Add import at the top:
   `import { setConnectionStatus } from './state/connection';`

2. In the `connectGateway()` function, set initial state to 'reconnecting' when connecting starts:
   - After `host.client?.stop()` and before creating new GatewayBrowserClient, call `setConnectionStatus('disconnected')`.

3. In the `onHello` callback (line ~121 area, where `host.connected = true`):
   - Add `setConnectionStatus('connected');` right after `host.connected = true;`

4. In the `onClose` callback (line ~138 area, where `host.connected = false`):
   - Add `setConnectionStatus('reconnecting');` right after `host.connected = false;`
   - This is correct because the GatewayBrowserClient automatically calls `scheduleReconnect()` on close (unless `this.closed` is true). The close handler fires BEFORE the reconnect timer, so 'reconnecting' is the right state.

5. Add a way to detect when the client is explicitly stopped (full disconnect, not reconnecting):
   - The client's `stop()` method sets `this.closed = true` which prevents reconnect.
   - In `connectGateway`, the existing `host.client?.stop()` call before creating a new client is a deliberate reconnect (not a permanent disconnect), so 'disconnected' -> 'reconnecting' is correct there.
   - For the case where the app truly disconnects (e.g., `disconnectedCallback` calls `client.stop()`), the `onClose` handler fires but reconnect won't happen since `closed=true`. However, `onClose` in app-gateway already sets `host.connected = false`. We should check: if the close was due to an explicit stop (code 1000 or 1005 with empty reason), set 'disconnected' instead of 'reconnecting'. The simplest approach:

   In the `onClose` callback:
   ```typescript
   onClose: ({ code, reason }) => {
     host.connected = false;
     // Normal closure or deliberate stop = truly disconnected (no auto-reconnect)
     // Otherwise the client will auto-reconnect
     if (code === 1000 || code === 1005) {
       setConnectionStatus('disconnected');
     } else {
       setConnectionStatus('reconnecting');
     }
     // ... rest of existing code
   }
   ```

IMPORTANT: Do NOT modify gateway.ts itself. The auto-reconnect logic (800ms -> 15s backoff with 1.7x factor) is already correct in GatewayBrowserClient. We are only adding signal updates to the app-gateway.ts wrapper that creates and configures the client.

Do NOT remove any existing `host.connected = true/false` assignments. The @state boolean must continue working since other parts of the app still read it. Signals are additive, not replacing @state yet.
  </action>
  <verify>
Run `cd /Users/lucassenechal/clawd/openclaw/ui && pnpm build` to confirm no type errors. Grep the built output to confirm setConnectionStatus is called in the gateway module.
  </verify>
  <done>
`app-gateway.ts` calls `setConnectionStatus('connected')` on hello, `setConnectionStatus('reconnecting')` on non-terminal close, and `setConnectionStatus('disconnected')` on terminal close or initial state. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create chat state signals and render connection indicator</name>
  <files>ui/src/ui/state/chat.ts, ui/src/ui/app-render.ts</files>
  <action>
**Part A: Create chat state signals module**

Create `ui/src/ui/state/chat.ts`:

```typescript
import { signal } from '@lit-labs/signals';

// Shared signal for chat messages — allows any component to reactively
// read the current message list without prop-drilling through AppViewState.
export const chatMessages = signal<unknown[]>([]);

// Shared signal for streaming text
export const chatStream = signal<string | null>(null);

// Shared signal for connection-aware send availability
export const chatSending = signal<boolean>(false);

// Mutation helpers
export function setChatMessages(messages: unknown[]) {
  chatMessages.set(messages);
}

export function pushChatMessage(message: unknown) {
  chatMessages.set([...chatMessages.get(), message]);
}

export function setChatStream(stream: string | null) {
  chatStream.set(stream);
}

export function setChatSending(sending: boolean) {
  chatSending.set(sending);
}
```

This is the signals layer that will be driven by existing chat controller mutations. For now, we wire it into the gateway event handler so that chat events update BOTH the @state properties AND the signals. Full migration from @state to signals-only happens in a later phase.

**Part B: Wire chat signals into the gateway event handler**

In `ui/src/ui/app-gateway.ts`, add these imports:
```typescript
import { setChatMessages, setChatStream, setChatSending } from './state/chat';
```

In the `handleGatewayEventUnsafe` function, in the `evt.event === "chat"` block, after the existing `handleChatEvent` call and its state checks, add signal updates:
- After `state === "delta"`: the existing code updates `state.chatStream` in chat controller. Add `setChatStream(host.chatStream)` (reading host's updated value after handleChatEvent).

Actually, the cleaner approach is to add signal syncing AFTER the handleChatEvent call returns, since it mutates the host directly:

```typescript
if (evt.event === "chat") {
  // ... existing code ...
  const state = handleChatEvent(host as unknown as OpenClawApp, payload);

  // Sync to signals layer
  setChatStream((host as unknown as { chatStream: string | null }).chatStream);

  if (state === "final" || state === "error" || state === "aborted") {
    // ... existing code ...
  }
  if (state === "final") {
    void loadChatHistory(host as unknown as OpenClawApp).then(() => {
      setChatMessages((host as unknown as { chatMessages: unknown[] }).chatMessages);
    });
  }
  return;
}
```

NOTE: Be careful with the existing `loadChatHistory` call. It's currently `void loadChatHistory(...)` with no `.then()`. You need to chain the signal sync after the history is loaded. Wrap it:

```typescript
if (state === "final") {
  void loadChatHistory(host as unknown as OpenClawApp).then(() => {
    setChatMessages((host as unknown as { chatMessages: unknown[] }).chatMessages);
  });
}
```

Also in the `onHello` callback in `connectGateway()`, after the existing `loadChatHistory` calls happen via `refreshActiveTab`, the chat messages will be loaded. This is harder to intercept. For now, focus on wiring the event-driven path (delta/final). The initial load sync can come later.

**Part C: Render connection indicator in the chat view**

Modify `ui/src/ui/app-render.ts`:

1. Add import for the connection-indicator component registration (side-effect import):
   `import './components/connection-indicator';`

2. Find where the chat tab content is rendered. Look for the area where the topbar or header of the chat view is rendered. The renderApp function likely delegates to renderChat from `./views/chat`.

Read the full `app-render.ts` to find the right insertion point. The connection indicator should appear in the topbar area near the session key selector or the chat header. Look for where `connected` state is referenced or where error messages are shown.

Add the `<connection-indicator></connection-indicator>` element in the topbar/header area of the chat view. A good location is next to the session selector or near the top of the chat panel. If the renderApp function has a topbar section that's always visible (not just chat tab), place it there instead — connection status is useful across all tabs.

The exact insertion point depends on the render structure. Read app-render.ts fully, find the topbar HTML, and add:
```html
<connection-indicator></connection-indicator>
```

Style it to fit: it should be small, unobtrusive, positioned in the header bar. If the topbar uses flexbox, the indicator can be added as a flex child.
  </action>
  <verify>
1. Run `cd /Users/lucassenechal/clawd/openclaw/ui && pnpm build` — must pass with no errors.
2. Verify the connection-indicator tag appears in app-render.ts.
3. Verify setConnectionStatus is called in app-gateway.ts (grep for it).
4. Verify state/chat.ts exports chatMessages, chatStream, pushChatMessage, setChatMessages.
  </verify>
  <done>
- `state/chat.ts` provides shared chat signals with mutation helpers
- `app-gateway.ts` drives both @state properties AND signal updates on chat events
- `app-gateway.ts` calls setConnectionStatus at all three lifecycle points (connect start, hello success, close)
- `<connection-indicator>` renders in the app topbar/header, visible across all connection states
- Build passes cleanly
  </done>
</task>

</tasks>

<verification>
Full phase verification (covers both plans):

1. **Auto-reconnect with backoff:** Kill the gateway process, observe the connection indicator change from "Connected" (green) to "Reconnecting..." (amber pulsing). Restart gateway, observe auto-reconnect without manual page refresh. Indicator returns to "Connected" (green).

2. **Reactive UI updates:** Send a chat message. The message appears in the chat view reactively via the signals layer. Streaming text updates in real-time.

3. **Connection status visible:** The connection indicator is visible in the UI header showing one of three states: Connected (green dot), Reconnecting (amber pulsing dot), Disconnected (red dot).

4. **Build health:** `pnpm build` in ui/ passes with zero errors.
</verification>

<success_criteria>
- Gateway lifecycle drives connectionStatus signal through all three states: disconnected -> reconnecting -> connected
- Connection indicator component renders in the app header, visible on all tabs
- Chat events update both @state properties (backward compat) and signals (new reactive layer)
- Auto-reconnect continues working as before (800ms -> 15s backoff) — no regression
- @lit-labs/signals is the reactive state backbone for cross-component updates
- UI build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/19-gateway-connection/19-02-SUMMARY.md`
</output>
