---
phase: 27.1-a2a-conversation-visibility
plan: 03
type: execute
wave: 2
depends_on: ["27.1-02"]
files_modified:
  - ui/src/ui/views/conversation-view.ts
  - ui/src/ui/views/agents.ts
autonomous: true

must_haves:
  truths:
    - "Clicking a session card with A2A conversation data shows a threaded conversation view with both agents' messages interleaved"
    - "Each message in the A2A thread shows the agent's name, color, and turn number"
    - "Messages from the requester agent appear left-aligned, messages from the target appear right-aligned"
    - "Session cards with A2A conversations show a visual indicator (conversation badge)"
    - "The back button returns from A2A view to session list"
  artifacts:
    - path: "ui/src/ui/views/conversation-view.ts"
      provides: "renderA2AConversation function for threaded A2A display"
      contains: "renderA2AConversation"
    - path: "ui/src/ui/views/agents.ts"
      provides: "A2A conversation indicator on session cards, A2A view routing"
      contains: "sessionA2ALinks"
  key_links:
    - from: "ui/src/ui/views/conversation-view.ts"
      to: "ui/src/ui/state/metrics.ts"
      via: "reads a2aConversations signal"
      pattern: "a2aConversations"
    - from: "ui/src/ui/views/agents.ts"
      to: "ui/src/ui/state/metrics.ts"
      via: "reads sessionA2ALinks computed signal"
      pattern: "sessionA2ALinks"
    - from: "ui/src/ui/views/agents.ts"
      to: "ui/src/ui/views/conversation-view.ts"
      via: "calls renderA2AConversation when session has A2A data"
      pattern: "renderA2AConversation"
---

<objective>
Render A2A conversations as threaded back-and-forth chat in the Agents tab, with conversation indicators on session cards.

Purpose: Users need to SEE the inter-agent conversations to understand what agents are discussing. This plan adds the visual rendering layer on top of the signal infrastructure from Plan 02.
Output: Threaded A2A conversation view in conversation-view.ts and session card A2A indicators in agents.ts.
</objective>

<execution_context>
@/Users/lucassenechal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lucassenechal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/27.1-a2a-conversation-visibility/27.1-02-SUMMARY.md
@ui/src/ui/views/conversation-view.ts
@ui/src/ui/views/agents.ts
@ui/src/ui/state/metrics.ts
@ui/src/ui/state/agents.ts
@ui/src/ui/markdown.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add A2A threaded conversation renderer to conversation-view.ts</name>
  <files>ui/src/ui/views/conversation-view.ts</files>
  <action>
Add a `renderA2AConversation` function to conversation-view.ts that renders a threaded back-and-forth view of an A2A conversation.

1. Add imports at the top (alongside existing imports from metrics):

```typescript
import {
  sessionConversations,
  sessionStreams,
  agentSessions,
  a2aConversations,
} from "../state/metrics";
```

(Merge with existing import -- just add `a2aConversations`.)

Also import the `A2AConversation` type:

```typescript
import type { A2AConversation } from "../state/metrics";
```

2. Add the `renderA2AConversation` export function after the existing `renderConversation` function:

```typescript
/**
 * Render a threaded A2A conversation view showing interleaved messages
 * from two agents in a back-and-forth chat layout.
 */
export function renderA2AConversation(conversationId: string, onBack: () => void) {
  const conversation = a2aConversations.get().get(conversationId);
  if (!conversation) {
    return html`
      <section class="card">
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:16px;">
          <button
            @click=${onBack}
            style="background:none;border:none;color:var(--text-primary,#cdd6f4);cursor:pointer;font-size:1.2rem;padding:4px 8px;border-radius:6px;"
            title="Back to sessions"
          >
            &larr;
          </button>
          <span style="color:var(--text-secondary,#a6adc8);">Conversation not found</span>
        </div>
      </section>
    `;
  }

  const [requesterAgent, targetAgent] = conversation.agents;
  const requesterIdentity = getAgentIdentity(requesterAgent);
  const targetIdentity = getAgentIdentity(targetAgent);
  const isComplete = conversation.status === "complete";

  // Reuse the same scroll logic from renderConversation
  function handleScroll(e: Event) {
    const el = e.target as HTMLElement;
    const atBottom = el.scrollHeight - el.scrollTop - el.clientHeight < 40;
    userScrolledUp = !atBottom;
  }

  function scrollToBottom() {
    userScrolledUp = false;
    const container = document.querySelector(".a2a-messages-container");
    if (container) {
      container.scrollTop = container.scrollHeight;
    }
  }

  return html`
    <section class="card" style="display:flex;flex-direction:column;height:100%;overflow:hidden;">
      <!-- Header -->
      <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px;flex-shrink:0;">
        <button
          @click=${onBack}
          style="background:none;border:none;color:var(--text-primary,#cdd6f4);cursor:pointer;font-size:1.2rem;padding:4px 8px;border-radius:6px;"
          title="Back to sessions"
        >
          &larr;
        </button>
        <agent-avatar
          .agentId=${requesterAgent}
          .color=${requesterIdentity.color}
          .name=${requesterIdentity.name}
          size="sm"
        ></agent-avatar>
        <span style="font-size:0.75rem;color:var(--text-secondary,#a6adc8);">&#8596;</span>
        <agent-avatar
          .agentId=${targetAgent}
          .color=${targetIdentity.color}
          .name=${targetIdentity.name}
          size="sm"
        ></agent-avatar>
        <div style="flex:1;min-width:0;">
          <div style="font-weight:600;color:var(--text-primary,#cdd6f4);">
            ${requesterIdentity.name} &harr; ${targetIdentity.name}
          </div>
          <div style="font-size:0.8rem;color:var(--text-secondary,#a6adc8);">
            A2A Conversation &middot; ${conversation.turns.length}
            turn${conversation.turns.length !== 1 ? "s" : ""}
          </div>
        </div>
        <span
          style="
          font-size:0.7rem;
          padding:3px 8px;
          border-radius:12px;
          background:${isComplete ? "#10b98122" : "#f59e0b22"};
          color:${isComplete ? "#10b981" : "#f59e0b"};
          font-weight:600;
          text-transform:uppercase;
          letter-spacing:0.04em;
          flex-shrink:0;
        "
          >${isComplete ? "complete" : "active"}</span
        >
      </div>

      <!-- Messages container -->
      <div
        class="a2a-messages-container"
        @scroll=${handleScroll}
        style="flex:1;overflow-y:auto;display:flex;flex-direction:column;gap:12px;padding:8px 0;min-height:0;"
      >
        ${conversation.turns.map((turn) => {
          const isRequester = turn.fromAgent === requesterAgent;
          const identity = isRequester ? requesterIdentity : targetIdentity;
          const alignment = isRequester ? "flex-start" : "flex-end";
          const bubbleBg = isRequester
            ? "var(--assistant-bubble-bg,#2d2d44)"
            : "var(--user-bubble-bg,#3d3d54)";
          const borderRadius = isRequester ? "10px 10px 10px 3px" : "10px 10px 3px 10px";

          return html`
            <div style="display:flex;gap:10px;align-items:flex-start;justify-content:${alignment};">
              ${isRequester
                ? html`
                    <agent-avatar
                      .agentId=${turn.fromAgent}
                      .color=${identity.color}
                      .name=${identity.name}
                      size="sm"
                    ></agent-avatar>
                  `
                : nothing}
              <div style="flex:0 1 auto;max-width:80%;min-width:0;">
                <div
                  style="display:flex;align-items:baseline;gap:6px;margin-bottom:2px;${isRequester
                    ? ""
                    : "justify-content:flex-end;"}"
                >
                  <span style="font-weight:600;font-size:0.8rem;color:${identity.color};"
                    >${identity.name}</span
                  >
                  <span style="font-size:0.6rem;opacity:0.4;">turn ${turn.turn}</span>
                  <span style="font-size:0.65rem;opacity:0.5;">
                    ${new Date(turn.timestamp).toLocaleTimeString([], {
                      hour: "numeric",
                      minute: "2-digit",
                      second: "2-digit",
                    })}
                  </span>
                </div>
                <div
                  style="
                  padding:8px 12px;
                  border-radius:${borderRadius};
                  background:${bubbleBg};
                  line-height:1.5;
                  word-wrap:break-word;
                  overflow-wrap:break-word;
                  font-size:0.875rem;
                "
                >
                  ${unsafeHTML(toSanitizedMarkdownHtml(turn.text))}
                </div>
              </div>
              ${!isRequester
                ? html`
                    <agent-avatar
                      .agentId=${turn.fromAgent}
                      .color=${identity.color}
                      .name=${identity.name}
                      size="sm"
                    ></agent-avatar>
                  `
                : nothing}
            </div>
          `;
        })}
        ${!isComplete
          ? html`
              <div style="text-align:center;padding:8px 0;">
                <typing-indicator
                  agentId="a2a"
                  agentName="agents"
                  agentColor="#6b7280"
                ></typing-indicator>
              </div>
            `
          : nothing}

        <div style="height:1px;flex-shrink:0;"></div>
      </div>

      <!-- Scroll-to-bottom button -->
      ${userScrolledUp
        ? html`
            <button
              @click=${scrollToBottom}
              style="
                align-self:center;
                margin-top:8px;
                padding:6px 16px;
                border-radius:16px;
                border:1px solid rgba(255,255,255,0.1);
                background:rgba(255,255,255,0.06);
                color:var(--text-secondary,#a6adc8);
                cursor:pointer;
                font-size:0.75rem;
                flex-shrink:0;
              "
            >
              Scroll to bottom
            </button>
          `
        : nothing}
    </section>

    <div
      style="display:none;"
      .hidden=${(() => {
        const container = document.querySelector(".a2a-messages-container") as Element | undefined;
        if (container) {
          requestAnimationFrame(() => {
            if (!userScrolledUp) {
              container.scrollTop = container.scrollHeight;
            }
          });
        }
        return true;
      })()}
    ></div>
  `;
}
```

The CSS variable `--user-bubble-bg` may not exist. Use a fallback: `var(--user-bubble-bg,#3d3d54)`. This gives a slightly different shade for the target agent's messages, making the back-and-forth visually distinguishable.

Important: Reuse the module-level `userScrolledUp` variable (already declared). The auto-scroll pattern mirrors the existing `renderConversation` exactly.
</action>
<verify>
Run `pnpm build` -- TypeScript compilation succeeds. Verify:

1. `renderA2AConversation` is exported
2. It reads `a2aConversations` signal
3. It uses `getAgentIdentity` for agent name/color
4. Messages are left/right aligned based on requester vs target
5. Auto-scroll pattern matches existing convention
   </verify>
   <done>
   conversation-view.ts exports `renderA2AConversation` that renders a threaded A2A chat view with left/right alignment, agent avatars, turn numbers, timestamps, markdown rendering, and auto-scroll.
   </done>
   </task>

<task type="auto">
  <name>Task 2: Add A2A indicators on session cards and A2A view routing in agents.ts</name>
  <files>ui/src/ui/views/agents.ts</files>
  <action>
Modify `renderAgentSessions` in agents.ts to:
1. Show a visual A2A conversation indicator on session cards
2. Route to A2A conversation view when a session with A2A data is selected

1. Add imports at the top of agents.ts (add to existing imports from metrics and conversation-view):

From metrics (add `sessionA2ALinks` and `a2aConversations` to the existing import):

```typescript
import { agentSessions, sessionA2ALinks, a2aConversations } from "../state/metrics.ts";
```

From conversation-view (add `renderA2AConversation` to existing import):

```typescript
import { renderConversation, renderA2AConversation } from "./conversation-view.ts";
```

2. Add a new signal for tracking selected A2A conversation (after the existing `selectedSession` signal):

```typescript
/** Currently selected A2A conversation for drill-down. */
const selectedA2AConversation = signal<string | null>(null);
```

3. Modify `renderAgentSessions` to handle A2A conversation selection. At the beginning of the function, BEFORE the existing `if (selected)` check for regular session, add A2A view routing:

```typescript
const selectedA2A = selectedA2AConversation.get();
if (selectedA2A) {
  return renderA2AConversation(selectedA2A, () => selectedA2AConversation.set(null));
}
```

4. In the session card rendering (inside the `sessions.map` callback), add an A2A indicator. After the `<agent-session-card>` element, add a conversation badge if the session has A2A data:

```typescript
${(() => {
  const links = sessionA2ALinks.get();
  const convIds = links.get(s.sessionKey);
  if (!convIds || convIds.length === 0) return nothing;
  return html`
    <div
      @click=${(e: Event) => {
        e.stopPropagation();
        selectedA2AConversation.set(convIds[0]);
      }}
      style="
        position:absolute;
        top:6px;
        right:6px;
        font-size:0.65rem;
        padding:2px 6px;
        border-radius:8px;
        background:rgba(59,130,246,0.15);
        color:#3b82f6;
        cursor:pointer;
        font-weight:600;
      "
      title="View A2A conversation"
    >A2A</div>
  `;
})()}
```

To make the badge position correctly, wrap the existing session card `<div>` in a container with `position:relative`:
Change the wrapper div from:

```html
<div @click="${...}" style="cursor:pointer;"></div>
```

To:

```html
<div @click="${...}" style="cursor:pointer;position:relative;"></div>
```

This way the A2A badge is positioned absolutely within the card wrapper.

Important: The `e.stopPropagation()` on the A2A badge click prevents the parent click handler (which opens the regular conversation view) from firing. Clicking the badge opens the A2A thread view; clicking elsewhere on the card opens the regular session conversation.
</action>
<verify>
Run `pnpm build` -- TypeScript compilation succeeds. Verify:

1. `sessionA2ALinks` and `a2aConversations` are imported from metrics
2. `renderA2AConversation` is imported from conversation-view
3. `selectedA2AConversation` signal exists
4. A2A view routing in `renderAgentSessions` precedes regular session routing
5. Session cards show A2A badge when sessionA2ALinks has entries
6. Clicking A2A badge sets selectedA2AConversation (with stopPropagation)
   </verify>
   <done>
   agents.ts shows A2A conversation indicators on session cards and routes to the threaded A2A view when clicked. Session cards that participate in A2A conversations display a blue "A2A" badge. Clicking the badge opens the A2A threaded view; clicking elsewhere opens the regular session conversation.
   </done>
   </task>

</tasks>

<verification>
1. `pnpm build` passes with no TypeScript errors
2. All existing tests pass: `pnpm test`
3. Grep for `renderA2AConversation` in conversation-view.ts -- confirms export
4. Grep for `selectedA2AConversation` in agents.ts -- confirms routing signal
5. Grep for `sessionA2ALinks` in agents.ts -- confirms badge rendering
</verification>

<success_criteria>
The Agents tab visually displays A2A conversations:

- Session cards with A2A data show a clickable "A2A" badge
- Clicking the badge opens a threaded conversation view showing interleaved messages from both agents
- Messages are left/right aligned to distinguish requester from target
- Each message shows agent avatar, name, turn number, and timestamp
- Markdown content renders correctly in message bubbles
- Auto-scroll keeps the view at the bottom during active conversations
- A "complete" or "active" status badge shows conversation state
  </success_criteria>

<output>
After completion, create `.planning/phases/27.1-a2a-conversation-visibility/27.1-03-SUMMARY.md`
</output>
