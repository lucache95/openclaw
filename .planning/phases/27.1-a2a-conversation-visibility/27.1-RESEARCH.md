# Phase 27.1: A2A Conversation Visibility - Research

**Researched:** 2026-02-03
**Domain:** Agent-to-agent event metadata enrichment + cross-session conversation threading in Lit UI
**Confidence:** HIGH

## Summary

Phase 27.1 makes inter-agent conversations (Ethos sending to GSD via `sessions_send`) visible in the Agents tab as a threaded back-and-forth chat. The A2A ping-pong mechanism already exists and works at the protocol level. The gap is purely in **metadata and UI threading**: events emitted during ping-pong turns carry no conversation context linking them across sessions, and the UI has no concept of cross-session conversation grouping.

The implementation touches three layers: (1) Backend event enrichment in `sessions-send-tool.a2a.ts` and `agent-step.ts` to emit conversation metadata, (2) Gateway passthrough of new metadata fields already works via the spread pattern in `server-chat.ts`, (3) UI state and rendering to merge events from two sessions into a unified conversation thread.

The critical insight is that the existing `AgentEventPayload` type and broadcast pipeline already support arbitrary `data` fields -- the `data: Record<string, unknown>` type means adding `conversationId`, `fromAgent`, `toAgent`, and `turn` requires no schema changes in the gateway layer. The UI already captures `assistant` stream events per-session in `AgentsController` and stores them in `sessionConversations`. The work is to add a parallel `a2aConversations` signal that groups messages by `conversationId` across sessions, and a new conversation thread view component.

**Primary recommendation:** Generate a `conversationId` at the start of `runSessionsSendA2AFlow`, pass it through to each `runAgentStep` call which embeds it in `emitAgentEvent` data, add a new `a2aConversations` signal in the UI state layer, and create a threaded conversation view component that interleaves messages from both agents.

## Standard Stack

No new dependencies. Everything is already in place.

### Core

| Library              | Version  | Purpose                            | Why Standard                                         |
| -------------------- | -------- | ---------------------------------- | ---------------------------------------------------- |
| lit                  | existing | Web component framework            | Already used throughout UI                           |
| @lit-labs/signals    | existing | Reactive state                     | Already used for agentSessions, sessionConversations |
| crypto (node:crypto) | built-in | UUID generation for conversationId | Already used in sessions-send-tool.ts                |

### Supporting

| Library                       | Version  | Purpose                        | When to Use                            |
| ----------------------------- | -------- | ------------------------------ | -------------------------------------- |
| lit/directives/unsafe-html.js | existing | Render sanitized markdown HTML | Message bubble content                 |
| marked + dompurify            | existing | Markdown rendering             | Already wired in ui/src/ui/markdown.ts |

### Alternatives Considered

| Instead of                   | Could Use                                  | Tradeoff                                                                                       |
| ---------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------- |
| conversationId in event data | Separate "a2a" stream type                 | Data field is simpler, no gateway schema changes; separate stream would need new event routing |
| Signal Map by conversationId | Derived computed from sessionConversations | Dedicated signal is cleaner; computed would require scanning all sessions every render         |
| Inline conversation view     | Separate route/page                        | Inline (expand within Agents tab) matches Phase 27 pattern and is simpler                      |

**Installation:**

```bash
# No installation needed -- zero new dependencies
```

## Architecture Patterns

### Recommended Project Structure

```
src/agents/tools/
  sessions-send-tool.a2a.ts  # MODIFY: generate conversationId, pass to runAgentStep
  agent-step.ts              # MODIFY: accept + forward conversationId in emitAgentEvent data
src/infra/
  agent-events.ts            # NO CHANGE: data is already Record<string, unknown>
src/gateway/
  server-chat.ts             # NO CHANGE: spread already passes all event fields
  server-broadcast.ts        # NO CHANGE: broadcasts full payload

ui/src/ui/
  state/
    metrics.ts               # MODIFY: add a2aConversations signal + mutators
  controllers/
    agents-controller.ts     # MODIFY: detect A2A metadata, route to a2aConversations
  views/
    agents.ts                # MODIFY: detect A2A conversations on session cards
    conversation-view.ts     # MODIFY: add A2A thread rendering path
  components/
    a2a-thread-view.ts       # NEW: threaded conversation component
```

### Pattern 1: ConversationId Generation at A2A Flow Start

**What:** Generate a UUID `conversationId` at the start of `runSessionsSendA2AFlow` and thread it through all subsequent `runAgentStep` calls. Each step's emitted events carry this ID, plus `fromAgent`/`toAgent`/`turn` metadata.
**When to use:** Every A2A ping-pong flow.
**Example:**

```typescript
// In sessions-send-tool.a2a.ts
export async function runSessionsSendA2AFlow(params: {
  // ... existing params ...
  conversationId?: string; // NEW: optional, generated if not provided
}) {
  const conversationId = params.conversationId ?? crypto.randomUUID();
  // ...
  for (let turn = 1; turn <= params.maxPingPongTurns; turn += 1) {
    const replyText = await runAgentStep({
      // ... existing params ...
      a2aContext: {
        // NEW
        conversationId,
        fromAgent: resolveAgentIdFromSessionKey(currentSessionKey),
        toAgent: resolveAgentIdFromSessionKey(nextSessionKey),
        turn,
        maxTurns: params.maxPingPongTurns,
      },
    });
    // ...
  }
}
```

### Pattern 2: A2A Metadata Emission in Agent Events

**What:** `runAgentStep` accepts an optional `a2aContext` and emits a dedicated `a2a` stream event (or enriches `lifecycle` events) with the conversation metadata.
**When to use:** Every agent step that is part of an A2A conversation.
**Example:**

```typescript
// In agent-step.ts -- emit A2A conversation event after step completes
import { emitAgentEvent } from "../../infra/agent-events.js";

export async function runAgentStep(params: {
  // ... existing params ...
  a2aContext?: {
    conversationId: string;
    fromAgent: string;
    toAgent: string;
    turn: number;
    maxTurns: number;
  };
}): Promise<string | undefined> {
  // ... existing step execution ...

  // After getting reply, emit A2A conversation event
  if (params.a2aContext && replyText) {
    emitAgentEvent({
      runId: resolvedRunId,
      stream: "a2a", // NEW stream type
      data: {
        conversationId: params.a2aContext.conversationId,
        fromAgent: params.a2aContext.fromAgent,
        toAgent: params.a2aContext.toAgent,
        turn: params.a2aContext.turn,
        maxTurns: params.a2aContext.maxTurns,
        text: replyText,
        phase: "turn",
      },
    });
  }

  return replyText;
}
```

### Pattern 3: UI Cross-Session Conversation Signal

**What:** A new signal `a2aConversations` keyed by `conversationId`, storing an ordered list of turn messages from both agents.
**When to use:** AgentsController routes events with `stream === "a2a"` to this signal.
**Example:**

```typescript
// In metrics.ts
export type A2ATurnMessage = {
  conversationId: string;
  fromAgent: string;
  toAgent: string;
  turn: number;
  maxTurns: number;
  text: string;
  timestamp: number;
  sessionKey?: string;
};

export type A2AConversation = {
  conversationId: string;
  agents: [string, string]; // [requester, target]
  turns: A2ATurnMessage[];
  startedAt: number;
  status: "active" | "complete";
};

export const a2aConversations = signal<Map<string, A2AConversation>>(new Map());
```

### Pattern 4: Conversation Thread View

**What:** A new component that renders an interleaved back-and-forth view with agent avatars on alternating sides, similar to a chat UI.
**When to use:** When clicking a session card that has associated A2A conversation data.
**Example:**

```typescript
// In a2a-thread-view.ts or conversation-view.ts
// Left-aligned messages = requester (Ethos)
// Right-aligned messages = target (GSD)
// Each message shows agent avatar, name, turn number, and text
```

### Anti-Patterns to Avoid

- **Modifying AgentEventPayload type for A2A fields:** The `data: Record<string, unknown>` is intentionally open. Do NOT add top-level fields to AgentEventPayload for conversation metadata. Keep A2A data inside `data`.
- **Polling for conversation state:** The gateway already pushes events via WebSocket. Do NOT add API endpoints to fetch conversation state. Use the event stream.
- **Coupling A2A events to the chat pipeline:** The A2A conversation events should NOT go through `emitChatDelta`/`emitChatFinal`. They are observation-only in the Agents tab, not interactive chat.
- **Storing full conversation history server-side:** The UI accumulates conversation turns from the event stream. No need for a persistence layer for A2A conversations -- they are ephemeral observation data.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem                | Don't Build                  | Use Instead                                              | Why                                                        |
| ---------------------- | ---------------------------- | -------------------------------------------------------- | ---------------------------------------------------------- |
| UUID generation        | Custom ID scheme             | `crypto.randomUUID()`                                    | Already used everywhere in sessions-send-tool.ts           |
| Agent identity display | Custom name/color resolution | `getAgentIdentity()` from `ui/src/ui/state/agents.ts`    | Already handles color hashing, registry lookup             |
| Markdown rendering     | Raw text display             | `toSanitizedMarkdownHtml()` from `ui/src/ui/markdown.ts` | Already wired with marked + dompurify + highlight.js       |
| Auto-scroll behavior   | Custom scroll logic          | Copy pattern from `conversation-view.ts`                 | Already handles scroll-lock, scroll-to-bottom, auto-scroll |
| Agent event broadcast  | Custom WebSocket logic       | Existing `broadcast("agent", agentPayload)` pipeline     | Events with `stream: "a2a"` flow through automatically     |

**Key insight:** The gateway broadcast pipeline already passes through ALL event data fields. Adding `stream: "a2a"` with conversation metadata in `data` requires zero gateway changes -- it just flows through.

## Common Pitfalls

### Pitfall 1: Event Ordering Across Sessions

**What goes wrong:** A2A turns alternate between two sessions (requester/target). Events from different sessions have independent `seq` counters per `runId`. If you try to order by `seq`, messages will be misordered.
**Why it happens:** Each `runAgentStep` call creates a new `runId` (via `crypto.randomUUID()` in agent-step.ts line 28). The `seq` counter in `agent-events.ts` is per-runId.
**How to avoid:** Use the `turn` number from A2A metadata for ordering, NOT `seq`. The turn number is monotonically increasing within a conversation.
**Warning signs:** Messages appearing out of order in the thread view.

### Pitfall 2: Round One Reply is Outside Ping-Pong Loop

**What goes wrong:** The initial message from Ethos to GSD and GSD's first reply happen BEFORE the ping-pong loop starts. The `runSessionsSendA2AFlow` receives `roundOneReply` as a parameter. If you only emit A2A events inside the ping-pong loop, you miss the first exchange.
**Why it happens:** Looking at `sessions-send-tool.ts` lines 330-398: the first `callGateway({ method: "agent" })` + `agent.wait` + `chat.history` happens in the main tool execution. The reply is passed as `roundOneReply` to `runSessionsSendA2AFlow`. The ping-pong loop starts at turn 1 AFTER this initial exchange.
**How to avoid:** Emit a turn-0 A2A event for the initial message AND for the round-one reply before the ping-pong loop begins. The `runSessionsSendA2AFlow` function has both `params.message` (original) and `primaryReply` (round one reply).
**Warning signs:** Conversation thread missing the first exchange.

### Pitfall 3: Announce Step is Not a Conversation Turn

**What goes wrong:** After the ping-pong loop, `runSessionsSendA2AFlow` runs an "announce step" (lines 98-135) that posts a summary to the target channel. This is NOT part of the conversation -- it's a delivery mechanism. If you emit it as a turn, the thread will show a confusing extra message.
**Why it happens:** The announce step uses `buildAgentToAgentAnnounceContext` to generate a summary for external delivery (e.g., Telegram). It's a separate concern from the A2A conversation.
**How to avoid:** Do NOT emit an A2A turn event for the announce step. Only emit for: (1) the initial message, (2) the round-one reply, (3) each ping-pong turn inside the loop. Emit a final "a2a complete" event after the loop ends.
**Warning signs:** Extra message at the end of the thread that doesn't fit the conversation flow.

### Pitfall 4: Session Key Mismatch Between Requester and Target

**What goes wrong:** The `requesterSessionKey` and `targetSessionKey` in the A2A flow are the raw internal session keys. The UI's `agentSessions` signal uses these same keys. But `resolveAgentIdFromSessionKey` extracts the agentId from these keys (e.g., "agent:ethos:..." -> "ethos"). If the extraction fails, `fromAgent`/`toAgent` will be wrong.
**Why it happens:** `resolveAgentIdFromSessionKey` is imported from `src/routing/session-key.ts`. It handles `agent:X:...` patterns but may return the full key for non-standard formats.
**How to avoid:** Use `resolveAgentIdFromSessionKey` consistently (it's already used in sessions-send-tool.ts line 235-236 for cross-agent detection). Test with actual session keys from Ethos/GSD.
**Warning signs:** Agent names showing as full session keys instead of "ethos"/"gsd".

### Pitfall 5: UI Signal Mutation Pattern

**What goes wrong:** Lit signals require immutable updates (new Map instance). If you mutate the existing Map in place, Lit won't detect the change and won't re-render.
**Why it happens:** The `signal<Map<>>` pattern used throughout metrics.ts requires `new Map(existing)` on every update.
**How to avoid:** Follow the exact pattern from `pushSessionMessage` in metrics.ts (line 162-170): create `new Map(...)`, modify the copy, then `.set()` the signal.
**Warning signs:** UI not updating when new A2A messages arrive.

### Pitfall 6: REPLY_SKIP Breaks Visible Conversation

**What goes wrong:** Either agent can stop the ping-pong by replying `REPLY_SKIP`. This is checked with `isReplySkip()` (sessions-send-helpers.ts line 154). If you emit the REPLY_SKIP text as a conversation turn, it shows "REPLY_SKIP" in the thread.
**Why it happens:** The REPLY_SKIP token is an internal protocol signal, not user-visible content.
**How to avoid:** Before emitting an A2A turn event, check `isReplySkip(replyText)`. If true, emit a "conversation ended" event instead of a turn with the REPLY_SKIP text. Import `isReplySkip` from sessions-send-helpers.ts.
**Warning signs:** "REPLY_SKIP" appearing as a message in the conversation thread.

## Code Examples

Verified patterns from the existing codebase:

### How Events Flow from Backend to UI (Existing Pipeline)

```
1. emitAgentEvent() in agent-events.ts
   ↓ (listeners)
2. createAgentEventHandler() in server-chat.ts
   ↓ (enriches with sessionKey, spawnedBy)
3. broadcast("agent", agentPayload) in server-broadcast.ts
   ↓ (WebSocket frame)
4. handleGatewayEvent() in app-gateway.ts
   ↓ (routes "agent" events)
5. agentsController.handleEvent() in agents-controller.ts
   ↓ (updates signals)
6. updateSessionFromEvent() + setSessionStream() + finalizeSessionStream() in metrics.ts
   ↓ (signal changes trigger re-render)
7. renderConversation() in conversation-view.ts reads signals
```

### How A2A Ping-Pong Works (Existing Code)

```
sessions-send-tool.ts:
  1. Resolve target session → callGateway({ method: "agent" }) → agent.wait
  2. Read reply from chat.history
  3. Call runSessionsSendA2AFlow() with roundOneReply

sessions-send-tool.a2a.ts (runSessionsSendA2AFlow):
  4. If no roundOneReply, wait for initial run to complete
  5. For turn 1..maxPingPongTurns:
     a. Build reply context with buildAgentToAgentReplyContext()
     b. runAgentStep(currentSession, incomingMessage, replyPrompt)
     c. If reply is empty or REPLY_SKIP → break
     d. Swap currentSession ↔ nextSession
  6. Run announce step → deliver summary to channel
```

### AgentsController Event Handling (Existing Pattern)

```typescript
// Source: ui/src/ui/controllers/agents-controller.ts
handleEvent(payload: AgentEventPayload | undefined): void {
  if (!payload) return;

  updateSessionFromEvent({ ... });

  const sessionKey = payload.sessionKey;
  if (!sessionKey) return;

  if (payload.stream === "assistant") {
    setSessionStream(sessionKey, agentId, text);
  } else if (payload.stream === "lifecycle") {
    if (phase === "end" || phase === "error") {
      finalizeSessionStream(sessionKey);
    }
  }
}
```

### Adding A2A Event Handling (New Pattern)

```typescript
// Extend AgentsController.handleEvent:
if (payload.stream === "a2a") {
  const data = payload.data;
  const conversationId = data.conversationId as string;
  if (!conversationId) return;

  if (data.phase === "turn") {
    pushA2ATurn(conversationId, {
      conversationId,
      fromAgent: data.fromAgent as string,
      toAgent: data.toAgent as string,
      turn: data.turn as number,
      maxTurns: data.maxTurns as number,
      text: data.text as string,
      timestamp: Date.now(),
      sessionKey,
    });
  } else if (data.phase === "complete") {
    finalizeA2AConversation(conversationId);
  }
}
```

### Linking Session Cards to A2A Conversations

```typescript
// To show a conversation indicator on a session card:
// Derive a computed signal that maps sessionKey -> conversationId[]
export const sessionA2ALinks = computed(() => {
  const links = new Map<string, string[]>();
  for (const [convId, conv] of a2aConversations.get()) {
    for (const turn of conv.turns) {
      if (turn.sessionKey) {
        const existing = links.get(turn.sessionKey) ?? [];
        if (!existing.includes(convId)) {
          existing.push(convId);
          links.set(turn.sessionKey, existing);
        }
      }
    }
  }
  return links;
});
```

## State of the Art

| Old Approach      | Current Approach                         | When Changed          | Impact                                                                    |
| ----------------- | ---------------------------------------- | --------------------- | ------------------------------------------------------------------------- |
| No A2A visibility | Per-session conversation only (Phase 27) | Phase 27 (just built) | Sessions show individual agent activity but not cross-agent conversations |
| N/A               | A2A ping-pong protocol exists            | Pre-existing          | Protocol works, events emit, but no conversation-level metadata           |

**What Phase 27 built (just completed):**

- `sessionConversations` signal (per-session message arrays)
- `sessionStreams` signal (per-session streaming text)
- `AgentsController.handleEvent()` capturing assistant text per session
- `renderConversation()` view with auto-scroll, scroll-lock
- `agent-session-card` component with click-to-open

**What Phase 27.1 adds on top:**

- `a2aConversations` signal (cross-session, keyed by conversationId)
- A2A metadata in emitted events (conversationId, fromAgent, toAgent, turn)
- Threaded conversation view interleaving messages from two agents
- Visual indicator on session cards that have A2A conversations

## Open Questions

Things that couldn't be fully resolved:

1. **Should the initial message (Ethos -> GSD) be captured as turn 0?**
   - What we know: The initial message is sent via `callGateway({ method: "agent" })` in sessions-send-tool.ts. The reply comes back via `chat.history`. The ping-pong loop starts after.
   - What's unclear: The initial message text is in `params.message` but the initial `callGateway` call happens before `runSessionsSendA2AFlow`. We'd need to either emit the turn-0 event from the main tool execution OR reconstruct it in the A2A flow from `params.message`.
   - Recommendation: Emit a "turn 0" pair (message + reply) at the start of `runSessionsSendA2AFlow`, using `params.message` and `primaryReply`. This keeps all A2A event emission in one place.

2. **Should A2A conversations persist across gateway restarts?**
   - What we know: Current `sessionConversations` is purely in-memory (signal state, not persisted). The UI resets on reconnect (`agentsController.reset()`).
   - What's unclear: Whether users expect to see past A2A conversations after a gateway restart.
   - Recommendation: Keep ephemeral for Phase 27.1. Persistence can be added later. Match the pattern of `sessionConversations` which also doesn't persist.

3. **How to handle multiple concurrent A2A conversations?**
   - What we know: Ethos could theoretically start multiple sessions_send calls to GSD simultaneously, each spawning its own A2A flow.
   - What's unclear: Whether this actually happens in practice.
   - Recommendation: The `conversationId` UUID makes this naturally safe -- each flow gets its own ID. The UI should support multiple conversations in the list.

4. **New "a2a" stream type vs enriching existing streams?**
   - What we know: Using a new `stream: "a2a"` would be cleanest for UI routing. But it means the gateway's tool event filtering (`shouldEmitToolEvents`) doesn't apply.
   - What's unclear: Whether there are any gateway-level filters that would block unknown stream types.
   - Recommendation: Use `stream: "a2a"`. The broadcast in `server-chat.ts` only filters `stream: "tool"` events (line 273). All other stream types pass through unconditionally. The UI's `AgentsController` already receives all events and can route by stream type.
   - Confidence: HIGH -- verified by reading server-chat.ts lines 258-291 where only "tool" stream has conditional filtering; "lifecycle", "assistant", and "error" pass through, and any other stream type would also pass through.

## Sources

### Primary (HIGH confidence)

- `src/agents/tools/sessions-send-tool.ts` -- A2A flow initiation, round-one handling
- `src/agents/tools/sessions-send-tool.a2a.ts` -- Ping-pong loop, announce step
- `src/agents/tools/agent-step.ts` -- Per-turn agent execution
- `src/agents/tools/sessions-send-helpers.ts` -- Reply context building, REPLY_SKIP, flow validation
- `src/infra/agent-events.ts` -- Event emission, AgentEventPayload type, listener system
- `src/gateway/server-chat.ts` -- Agent event handler, broadcast routing, tool filtering
- `src/gateway/server-broadcast.ts` -- WebSocket broadcast to all clients
- `src/gateway/server.impl.ts` -- Gateway wiring (onAgentEvent -> createAgentEventHandler)
- `ui/src/ui/controllers/agents-controller.ts` -- Event -> signal bridging
- `ui/src/ui/state/metrics.ts` -- Session signals, conversation signals, mutators
- `ui/src/ui/views/conversation-view.ts` -- Existing conversation rendering
- `ui/src/ui/views/agents.ts` -- Session card list, click-to-conversation
- `ui/src/ui/app-gateway.ts` -- WebSocket event routing to AgentsController
- `ui/src/ui/state/agents.ts` -- Agent identity, color hashing

### Secondary (MEDIUM confidence)

- `src/agents/pi-embedded-subscribe.handlers.lifecycle.ts` -- Lifecycle event emission pattern
- `src/agents/pi-embedded-subscribe.handlers.messages.ts` -- Assistant text event emission pattern
- `src/gateway/server-methods/agent.ts` -- registerAgentRunContext call pattern

### Tertiary (LOW confidence)

- None -- all findings verified directly from codebase

## Metadata

**Confidence breakdown:**

- Standard stack: HIGH -- no new dependencies, all patterns from existing codebase
- Architecture: HIGH -- extension of existing signal/controller/view pattern from Phase 27
- Event pipeline: HIGH -- verified broadcast passthrough by reading server-chat.ts source
- Pitfalls: HIGH -- identified from direct code reading of A2A flow
- UI patterns: HIGH -- direct extension of patterns built in Phase 27

**Research date:** 2026-02-03
**Valid until:** 2026-03-03 (stable internal codebase, no external dependency changes expected)
