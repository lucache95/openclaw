---
phase: 27.1-a2a-conversation-visibility
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - ui/src/ui/state/metrics.ts
  - ui/src/ui/controllers/agents-controller.ts
autonomous: true

must_haves:
  truths:
    - "A2A conversation turns accumulate in a2aConversations signal keyed by conversationId"
    - "AgentsController routes stream 'a2a' events to the a2aConversations signal"
    - "Completed A2A conversations are marked with status 'complete'"
    - "Signal mutations follow immutable Map pattern (new Map on every update)"
  artifacts:
    - path: "ui/src/ui/state/metrics.ts"
      provides: "A2ATurnMessage type, A2AConversation type, a2aConversations signal, pushA2ATurn, finalizeA2AConversation mutators"
      contains: "a2aConversations"
    - path: "ui/src/ui/controllers/agents-controller.ts"
      provides: "A2A event routing in handleEvent method"
      contains: "stream.*a2a"
  key_links:
    - from: "ui/src/ui/controllers/agents-controller.ts"
      to: "ui/src/ui/state/metrics.ts"
      via: "import pushA2ATurn, finalizeA2AConversation"
      pattern: "pushA2ATurn|finalizeA2AConversation"
---

<objective>
Add the UI state layer for A2A conversations: types, signals, mutators, and controller routing.

Purpose: The UI needs reactive state to accumulate A2A conversation turns from gateway events and make them available to view components. This plan builds the data layer without any rendering changes.
Output: New signal `a2aConversations` in metrics.ts, mutator functions, and AgentsController routing for `stream === "a2a"` events.
</objective>

<execution_context>
@/Users/lucassenechal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lucassenechal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@ui/src/ui/state/metrics.ts
@ui/src/ui/controllers/agents-controller.ts
@ui/src/ui/app-tool-stream.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add A2A types, signal, and mutators to metrics.ts</name>
  <files>ui/src/ui/state/metrics.ts</files>
  <action>
Add the A2A conversation state layer to metrics.ts, following the exact same patterns as the existing sessionConversations signal.

1. Add types after the existing `ConversationMessage` type:

```typescript
export type A2ATurnMessage = {
  conversationId: string;
  fromAgent: string;
  toAgent: string;
  turn: number;
  maxTurns: number;
  text: string;
  timestamp: number;
  sessionKey?: string;
};

export type A2AConversation = {
  conversationId: string;
  agents: [string, string];
  turns: A2ATurnMessage[];
  startedAt: number;
  status: "active" | "complete";
};
```

2. Add the signal after the existing `sessionStreams` signal:

```typescript
export const a2aConversations = signal<Map<string, A2AConversation>>(new Map());
```

3. Add a computed signal for linking sessions to A2A conversations (used by session cards):

```typescript
export const sessionA2ALinks = computed(() => {
  const links = new Map<string, string[]>();
  for (const [convId, conv] of a2aConversations.get()) {
    for (const turn of conv.turns) {
      if (turn.sessionKey) {
        const existing = links.get(turn.sessionKey) ?? [];
        if (!existing.includes(convId)) {
          existing.push(convId);
          links.set(turn.sessionKey, existing);
        }
      }
    }
  }
  return links;
});
```

4. Add mutator functions after the existing conversation mutators section:

```typescript
// --- A2A conversation mutators ---

/** Add a turn to an A2A conversation. Creates the conversation if it doesn't exist. */
export function pushA2ATurn(turn: A2ATurnMessage): void {
  const next = new Map(a2aConversations.get());
  const existing = next.get(turn.conversationId);
  if (existing) {
    const updatedTurns = [...existing.turns, turn];
    next.set(turn.conversationId, {
      ...existing,
      turns: updatedTurns,
    });
  } else {
    next.set(turn.conversationId, {
      conversationId: turn.conversationId,
      agents: [turn.fromAgent, turn.toAgent],
      turns: [turn],
      startedAt: turn.timestamp,
      status: "active",
    });
  }
  a2aConversations.set(next);
}

/** Mark an A2A conversation as complete. */
export function finalizeA2AConversation(conversationId: string): void {
  const next = new Map(a2aConversations.get());
  const existing = next.get(conversationId);
  if (existing) {
    next.set(conversationId, {
      ...existing,
      status: "complete",
    });
    a2aConversations.set(next);
  }
}
```

5. Update `resetMetrics` to also clear A2A state:
   Add `a2aConversations.set(new Map());` inside the existing `resetMetrics` function.

Important: Follow the EXACT immutable Map pattern used by `pushSessionMessage` -- always create `new Map(...)` before setting the signal. Lit signals require this for reactivity.
</action>
<verify>
Run `pnpm build` -- TypeScript compilation succeeds. Verify:

1. `A2ATurnMessage` and `A2AConversation` types are exported
2. `a2aConversations` signal is exported
3. `sessionA2ALinks` computed signal is exported
4. `pushA2ATurn` and `finalizeA2AConversation` are exported
5. `resetMetrics` clears `a2aConversations`
   </verify>
   <done>
   metrics.ts has A2A types, signal, computed link signal, and mutators. The signal follows the same immutable Map pattern as existing signals. resetMetrics clears A2A state.
   </done>
   </task>

<task type="auto">
  <name>Task 2: Route A2A events in AgentsController</name>
  <files>ui/src/ui/controllers/agents-controller.ts</files>
  <action>
Extend `AgentsController.handleEvent` to route `stream === "a2a"` events to the A2A signal layer.

1. Update the import from metrics to include the new functions:

```typescript
import {
  updateSessionFromEvent,
  resetMetrics,
  setSessionStream,
  finalizeSessionStream,
  pushA2ATurn,
  finalizeA2AConversation,
} from "../state/metrics";
```

2. Add A2A event handling AFTER the existing `else if (payload.stream === "lifecycle")` block, before the closing `}` of `handleEvent`:

```typescript
else if (payload.stream === "a2a") {
  const data = payload.data;
  const conversationId = data?.conversationId as string | undefined;
  if (!conversationId) return;

  if (data.phase === "turn") {
    pushA2ATurn({
      conversationId,
      fromAgent: (data.fromAgent as string) ?? "unknown",
      toAgent: (data.toAgent as string) ?? "unknown",
      turn: (data.turn as number) ?? 0,
      maxTurns: (data.maxTurns as number) ?? 0,
      text: (data.text as string) ?? "",
      timestamp: Date.now(),
      sessionKey,
    });
  } else if (data.phase === "complete") {
    finalizeA2AConversation(conversationId);
  }
}
```

Note: The `sessionKey` variable is already declared and assigned earlier in the method (`const sessionKey = payload.sessionKey;`). The A2A handler uses it to link turns to sessions for the sessionA2ALinks computed signal.
</action>
<verify>
Run `pnpm build` -- TypeScript compilation succeeds. Verify:

1. `pushA2ATurn` and `finalizeA2AConversation` are imported
2. The `else if (payload.stream === "a2a")` block exists in handleEvent
3. Turn events call `pushA2ATurn` with all required fields
4. Complete events call `finalizeA2AConversation`
   </verify>
   <done>
   AgentsController routes `stream === "a2a"` events: turn events accumulate in a2aConversations signal, complete events mark conversations as finished. Each turn is linked to its sessionKey for session-card cross-referencing.
   </done>
   </task>

</tasks>

<verification>
1. `pnpm build` passes with no TypeScript errors
2. All existing tests pass: `pnpm test`
3. Grep for `a2aConversations` in metrics.ts -- confirms signal exists
4. Grep for `pushA2ATurn` in agents-controller.ts -- confirms routing
5. Grep for `resetMetrics` in metrics.ts -- confirms A2A cleanup included
</verification>

<success_criteria>
UI state layer accepts A2A conversation events and stores them in reactive signals. AgentsController routes `stream: "a2a"` events to the signal layer. Conversations are tracked by conversationId with ordered turns, agent identification, and session linking. The resetMetrics function clears A2A state on reconnect.
</success_criteria>

<output>
After completion, create `.planning/phases/27.1-a2a-conversation-visibility/27.1-02-SUMMARY.md`
</output>
