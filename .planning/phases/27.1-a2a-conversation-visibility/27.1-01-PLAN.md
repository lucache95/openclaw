---
phase: 27.1-a2a-conversation-visibility
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/agents/tools/sessions-send-tool.a2a.ts
  - src/agents/tools/agent-step.ts
autonomous: true

must_haves:
  truths:
    - "Every A2A ping-pong turn emits an event with stream 'a2a' containing conversationId, fromAgent, toAgent, turn, and text"
    - "The initial message and round-one reply are captured as turn 0 pair before the ping-pong loop"
    - "REPLY_SKIP responses do not emit a turn event -- they emit a 'complete' phase event instead"
    - "The announce step does NOT emit an A2A turn event"
  artifacts:
    - path: "src/agents/tools/sessions-send-tool.a2a.ts"
      provides: "conversationId generation, turn-0 emission, a2aContext passing to runAgentStep"
      contains: "conversationId"
    - path: "src/agents/tools/agent-step.ts"
      provides: "a2aContext parameter, A2A event emission after step completion"
      contains: "a2aContext"
  key_links:
    - from: "src/agents/tools/sessions-send-tool.a2a.ts"
      to: "src/agents/tools/agent-step.ts"
      via: "a2aContext parameter passed to runAgentStep"
      pattern: "a2aContext"
    - from: "src/agents/tools/agent-step.ts"
      to: "src/infra/agent-events.ts"
      via: "emitAgentEvent with stream 'a2a'"
      pattern: "emitAgentEvent.*stream.*a2a"
---

<objective>
Emit A2A conversation events from the backend ping-pong flow so the gateway broadcast pipeline carries conversation metadata to UI clients.

Purpose: Without conversation events, the UI has no data to display A2A threaded conversations. This plan adds the event emission layer.
Output: Modified sessions-send-tool.a2a.ts and agent-step.ts that emit `stream: "a2a"` events with conversation metadata through the existing broadcast pipeline (zero gateway changes needed).
</objective>

<execution_context>
@/Users/lucassenechal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lucassenechal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/agents/tools/sessions-send-tool.a2a.ts
@src/agents/tools/agent-step.ts
@src/infra/agent-events.ts
@src/agents/tools/sessions-send-helpers.ts
@src/routing/session-key.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add a2aContext parameter to runAgentStep and emit A2A events</name>
  <files>src/agents/tools/agent-step.ts</files>
  <action>
Modify `runAgentStep` to accept an optional `a2aContext` parameter and emit A2A conversation events.

1. Add import for `emitAgentEvent` from `../../infra/agent-events.js`.

2. Extend the `runAgentStep` params type with an optional field:

```typescript
a2aContext?: {
  conversationId: string;
  fromAgent: string;
  toAgent: string;
  turn: number;
  maxTurns: number;
};
```

3. After the existing `readLatestAssistantReply` call at the end of `runAgentStep` (the `return` statement), capture the reply text and emit an A2A event BEFORE returning:

```typescript
const replyText = await readLatestAssistantReply({ sessionKey: params.sessionKey });

if (params.a2aContext && replyText) {
  emitAgentEvent({
    runId: resolvedRunId,
    stream: "a2a",
    data: {
      conversationId: params.a2aContext.conversationId,
      fromAgent: params.a2aContext.fromAgent,
      toAgent: params.a2aContext.toAgent,
      turn: params.a2aContext.turn,
      maxTurns: params.a2aContext.maxTurns,
      text: replyText,
      phase: "turn",
    },
  });
}

return replyText;
```

Important: The `emitAgentEvent` function auto-assigns `seq`, `ts`, and enriches with `sessionKey` from the run context. The `stream: "a2a"` type passes through the gateway broadcast unconditionally (only `stream: "tool"` is conditionally filtered in server-chat.ts).

Do NOT change `readLatestAssistantReply` -- it stays as-is.
</action>
<verify>
Run `pnpm build` -- TypeScript compilation succeeds with no errors. Verify the new `a2aContext` parameter is optional so existing callers are unaffected.
</verify>
<done>
`runAgentStep` accepts optional `a2aContext` and emits `stream: "a2a"` events with conversation metadata when context is provided. Existing callers (without a2aContext) are unaffected.
</done>
</task>

<task type="auto">
  <name>Task 2: Generate conversationId in A2A flow and pass a2aContext to each turn</name>
  <files>src/agents/tools/sessions-send-tool.a2a.ts</files>
  <action>
Modify `runSessionsSendA2AFlow` to generate a conversationId and emit A2A conversation events.

1. Import `emitAgentEvent` from `../../infra/agent-events.js`.
2. Import `resolveAgentIdFromSessionKey` from `../../routing/session-key.js`.

3. At the start of the try block (after `const runContextId = ...`), generate the conversation ID:

```typescript
const conversationId = crypto.randomUUID();
```

4. Resolve agent IDs from session keys for the fromAgent/toAgent fields. Use `resolveAgentIdFromSessionKey`:

```typescript
const requesterAgentId = params.requesterSessionKey
  ? resolveAgentIdFromSessionKey(params.requesterSessionKey)
  : "unknown";
const targetAgentId = resolveAgentIdFromSessionKey(params.targetSessionKey);
```

5. After `primaryReply` is resolved (after the `if (!latestReply) return;` guard), emit a turn-0 pair. The initial message from requester is turn 0, the round-one reply is turn 1:

```typescript
// Emit turn 0: requester's initial message
emitAgentEvent({
  runId: runContextId,
  stream: "a2a",
  data: {
    conversationId,
    fromAgent: requesterAgentId,
    toAgent: targetAgentId,
    turn: 0,
    maxTurns: params.maxPingPongTurns,
    text: params.message,
    phase: "turn",
  },
});

// Emit turn 1: target's round-one reply
if (primaryReply) {
  emitAgentEvent({
    runId: runContextId,
    stream: "a2a",
    data: {
      conversationId,
      fromAgent: targetAgentId,
      toAgent: requesterAgentId,
      turn: 1,
      maxTurns: params.maxPingPongTurns,
      text: primaryReply,
      phase: "turn",
    },
  });
}
```

6. Inside the ping-pong for loop, pass `a2aContext` to each `runAgentStep` call. Determine fromAgent/toAgent based on currentSessionKey:

```typescript
const currentAgentId =
  currentSessionKey === params.requesterSessionKey ? requesterAgentId : targetAgentId;
const otherAgentId = currentAgentId === requesterAgentId ? targetAgentId : requesterAgentId;
```

Then add `a2aContext` to the existing `runAgentStep` call:

```typescript
const replyText = await runAgentStep({
  sessionKey: currentSessionKey,
  message: incomingMessage,
  extraSystemPrompt: replyPrompt,
  timeoutMs: params.announceTimeoutMs,
  lane: AGENT_LANE_NESTED,
  a2aContext: {
    conversationId,
    fromAgent: currentAgentId,
    toAgent: otherAgentId,
    turn: turn + 1, // +1 because turns 0,1 are pre-loop
    maxTurns: params.maxPingPongTurns,
  },
});
```

7. When the loop exits (either naturally or via REPLY_SKIP/empty check), emit a "complete" event AFTER the loop but BEFORE the announce step:

```typescript
emitAgentEvent({
  runId: runContextId,
  stream: "a2a",
  data: {
    conversationId,
    fromAgent: requesterAgentId,
    toAgent: targetAgentId,
    phase: "complete",
  },
});
```

8. Do NOT pass a2aContext to the announce step's `runAgentStep` call -- the announce is not a conversation turn.

Important pitfalls to avoid:

- Do NOT emit REPLY_SKIP text as a turn. The existing `if (!replyText || isReplySkip(replyText)) break;` already breaks before emitting (since the a2aContext emission happens inside runAgentStep, which only emits if replyText is truthy). But verify that `isReplySkip` replies are NOT emitted: in agent-step.ts, `readLatestAssistantReply` returns the raw text including REPLY_SKIP. The emission guard `if (params.a2aContext && replyText)` will fire. So add an additional guard in agent-step.ts: import `isReplySkip` from `./sessions-send-helpers.js` and change the guard to `if (params.a2aContext && replyText && !isReplySkip(replyText))`.

Go back to agent-step.ts and add:

- Import `isReplySkip` from `./sessions-send-helpers.js`
- Change the A2A emission guard to: `if (params.a2aContext && replyText && !isReplySkip(replyText))`
  </action>
  <verify>
  Run `pnpm build` -- TypeScript compilation succeeds. Verify:

1. `conversationId` is generated with `crypto.randomUUID()`
2. Turn 0 (message) and turn 1 (roundOneReply) are emitted before the loop
3. Each ping-pong turn passes `a2aContext` to `runAgentStep`
4. A "complete" event is emitted after the loop
5. The announce step does NOT pass a2aContext
6. REPLY_SKIP is filtered out of A2A event emission
   </verify>
   <done>
   `runSessionsSendA2AFlow` generates a conversationId, emits turn-0/1 for the initial exchange, threads a2aContext through all ping-pong turns, emits a "complete" event after the loop, and excludes the announce step. REPLY_SKIP responses are filtered from A2A events.
   </done>
   </task>

</tasks>

<verification>
1. `pnpm build` passes with no TypeScript errors
2. All existing tests pass: `pnpm test`
3. Grep for `stream: "a2a"` in agent-step.ts -- confirms event emission
4. Grep for `conversationId` in sessions-send-tool.a2a.ts -- confirms UUID generation
5. Grep for `isReplySkip` in agent-step.ts -- confirms REPLY_SKIP filtering
6. The announce step's runAgentStep call does NOT have a2aContext parameter
</verification>

<success_criteria>
Backend emits A2A conversation events with `stream: "a2a"` for every ping-pong turn, including the initial exchange. Events carry conversationId, fromAgent, toAgent, turn number, and message text. REPLY_SKIP is filtered. The announce step is excluded. The gateway broadcasts these events to UI clients without any gateway code changes.
</success_criteria>

<output>
After completion, create `.planning/phases/27.1-a2a-conversation-visibility/27.1-01-SUMMARY.md`
</output>
