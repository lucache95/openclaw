---
phase: 27-conversation-view
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ui/src/ui/state/metrics.ts
  - ui/src/ui/controllers/agents-controller.ts
autonomous: true

must_haves:
  truths:
    - "Per-session conversation messages accumulate from assistant stream events"
    - "Stream finalization on lifecycle.end moves streaming text to completed messages"
    - "Memory is bounded with a 500-message cap per session"
  artifacts:
    - path: "ui/src/ui/state/metrics.ts"
      provides: "sessionConversations signal, sessionStreams signal, mutator functions"
      contains: "sessionConversations"
    - path: "ui/src/ui/controllers/agents-controller.ts"
      provides: "Extended handleEvent capturing assistant/lifecycle events for conversations"
      contains: "setSessionStream"
  key_links:
    - from: "ui/src/ui/controllers/agents-controller.ts"
      to: "ui/src/ui/state/metrics.ts"
      via: "import and call setSessionStream/pushSessionMessage/clearSessionStream/finalizeSessionStream"
      pattern: "(setSessionStream|pushSessionMessage|finalizeSessionStream)"
---

<objective>
Add per-session conversation state signals and extend AgentsController to capture assistant stream events into conversation data.

Purpose: This is the data layer for the conversation view. Without per-session conversation signals and event capture, there is no data for the UI to display. This plan creates the foundation that Plan 02's conversation view renders.

Output: sessionConversations and sessionStreams signals in metrics.ts, extended handleEvent in agents-controller.ts that routes assistant/lifecycle events to conversation state.
</objective>

<execution_context>
@/Users/lucassenechal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lucassenechal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-conversation-view/27-RESEARCH.md

# Source files being modified
@ui/src/ui/state/metrics.ts
@ui/src/ui/controllers/agents-controller.ts

# Type reference
@ui/src/ui/app-tool-stream.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add per-session conversation signals and mutators to metrics.ts</name>
  <files>ui/src/ui/state/metrics.ts</files>
  <action>
Add the following to ui/src/ui/state/metrics.ts, after the existing signals and before the mutators section:

1. Add a ConversationMessage type:
```typescript
export type ConversationMessage = {
  agentId: string;
  text: string;
  timestamp: number;
  role: "assistant" | "system" | "tool";
};
```

2. Add two new signals after agentCosts:
```typescript
export const sessionConversations = signal<Map<string, ConversationMessage[]>>(new Map());
export const sessionStreams = signal<Map<string, { agentId: string; text: string }>>(new Map());
```

3. Add mutator functions after the existing mutators section:
- `pushSessionMessage(sessionKey: string, msg: ConversationMessage)` -- Appends a message to the session's conversation array. Caps at 500 messages by slicing from the end if exceeded. Uses the standard `new Map(signal.get())` immutable update pattern.
- `setSessionStream(sessionKey: string, agentId: string, text: string)` -- Sets or updates the active streaming text for a session. Same immutable Map pattern.
- `clearSessionStream(sessionKey: string)` -- Deletes a session's entry from sessionStreams. Same immutable Map pattern.
- `finalizeSessionStream(sessionKey: string)` -- Takes the current stream text for the session from sessionStreams, pushes it as a completed ConversationMessage with role "assistant" and timestamp Date.now() into sessionConversations, then clears the stream. If no stream exists for the session, this is a no-op.

4. Update `resetMetrics()` to also clear the two new signals:
```typescript
sessionConversations.set(new Map());
sessionStreams.set(new Map());
```

The 500-message cap in pushSessionMessage should use: `if (messages.length > 500) messages = messages.slice(-500);` to keep the most recent messages.
  </action>
  <verify>Run `pnpm build` from the project root. Verify no TypeScript compilation errors in metrics.ts. Grep for `sessionConversations` and `sessionStreams` to confirm exports exist.</verify>
  <done>metrics.ts exports ConversationMessage type, sessionConversations signal, sessionStreams signal, and 4 mutator functions (pushSessionMessage, setSessionStream, clearSessionStream, finalizeSessionStream). resetMetrics clears all 4 signals. Build passes.</done>
</task>

<task type="auto">
  <name>Task 2: Extend AgentsController.handleEvent to capture conversation data</name>
  <files>ui/src/ui/controllers/agents-controller.ts</files>
  <action>
Extend the handleEvent method in AgentsController to capture assistant stream events and lifecycle finalization for conversation data.

1. Add imports at top:
```typescript
import {
  updateSessionFromEvent,
  resetMetrics,
  setSessionStream,
  finalizeSessionStream,
} from "../state/metrics";
```

2. After the existing `updateSessionFromEvent(...)` call in handleEvent, add conversation capture logic:

```typescript
// Capture conversation data
const sessionKey = payload.sessionKey;
if (!sessionKey) return;

if (payload.stream === "assistant") {
  const text = payload.data?.text as string | undefined;
  const agentId = (payload.data?.agentId as string) ?? sessionKey;
  if (typeof text === "string") {
    setSessionStream(sessionKey, agentId, text);
  }
} else if (payload.stream === "lifecycle") {
  const phase = payload.data?.phase as string | undefined;
  if (phase === "end" || phase === "error") {
    finalizeSessionStream(sessionKey);
  }
}
```

Key points:
- The `updateSessionFromEvent` call remains first (it handles the session card state).
- The conversation capture runs after, on the same payload.
- For assistant events, `data.text` contains the full accumulated text (not just delta). Store the full text each time -- the signal value is replaced, not appended.
- AgentId is extracted from `data.agentId` with fallback to sessionKey.
- On lifecycle end/error, `finalizeSessionStream` moves the active stream text to completed messages.
- Do NOT capture lifecycle.start as a conversation message (it's a session event, not a chat message).
  </action>
  <verify>Run `pnpm build` from the project root. Verify no TypeScript compilation errors. Read the file to confirm the handleEvent method calls both updateSessionFromEvent and the new conversation capture code.</verify>
  <done>AgentsController.handleEvent captures assistant stream events into sessionStreams and finalizes them into sessionConversations on lifecycle.end/error. Build passes with no errors.</done>
</task>

</tasks>

<verification>
1. `pnpm build` passes with no errors
2. metrics.ts exports: ConversationMessage, sessionConversations, sessionStreams, pushSessionMessage, setSessionStream, clearSessionStream, finalizeSessionStream
3. agents-controller.ts imports and calls setSessionStream and finalizeSessionStream
4. resetMetrics() clears all 4 signal maps
</verification>

<success_criteria>
- Per-session conversation signals exist and are populated from gateway agent events
- Stream finalization correctly moves active stream text to completed messages on lifecycle.end/error
- Memory is bounded by 500-message cap per session
- Existing session card functionality (updateSessionFromEvent) is unaffected
- Build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/27-conversation-view/27-01-SUMMARY.md`
</output>
