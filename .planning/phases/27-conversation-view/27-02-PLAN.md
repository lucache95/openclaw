---
phase: 27-conversation-view
plan: 02
type: execute
wave: 2
depends_on: ["27-01"]
files_modified:
  - ui/src/ui/views/conversation-view.ts
  - ui/src/ui/views/agents.ts
  - ui/src/ui/components/message-stream.ts
autonomous: false

must_haves:
  truths:
    - "Clicking a session card opens a live conversation view showing agent messages"
    - "Each message bubble shows agent avatar, name, and color"
    - "Active streaming text displays with blinking cursor via message-stream"
    - "Typing indicator shows when an agent is streaming"
    - "Messages auto-scroll to newest content, scrolling up pauses auto-scroll"
    - "Markdown and code blocks render with proper formatting"
    - "Back button returns to the session card grid"
  artifacts:
    - path: "ui/src/ui/views/conversation-view.ts"
      provides: "renderConversation function composing agent messages with markdown rendering"
      contains: "renderConversation"
    - path: "ui/src/ui/views/agents.ts"
      provides: "Session card click handler, conditional conversation view rendering, back button"
      contains: "selectedSession"
    - path: "ui/src/ui/components/message-stream.ts"
      provides: "Optional streamText property for per-session streaming"
      contains: "streamText"
  key_links:
    - from: "ui/src/ui/views/agents.ts"
      to: "ui/src/ui/views/conversation-view.ts"
      via: "import renderConversation, render when selectedSession is set"
      pattern: "renderConversation"
    - from: "ui/src/ui/views/conversation-view.ts"
      to: "ui/src/ui/state/metrics.ts"
      via: "import sessionConversations and sessionStreams signals"
      pattern: "sessionConversations\\.get\\(\\)"
    - from: "ui/src/ui/views/conversation-view.ts"
      to: "ui/src/ui/markdown.ts"
      via: "import toSanitizedMarkdownHtml for message rendering"
      pattern: "toSanitizedMarkdownHtml"
    - from: "ui/src/ui/views/conversation-view.ts"
      to: "ui/src/ui/components/message-stream.ts"
      via: "uses message-stream with streamText property for active streaming"
      pattern: "message-stream"
---

<objective>
Create the conversation view that renders agent-to-agent conversations with live streaming, auto-scroll, and markdown formatting. Wire session card clicks to open the conversation view.

Purpose: This is the user-facing feature -- the ability to click a session card and watch a live agent conversation stream with rich formatting, typing indicators, and smart auto-scroll.

Output: New conversation-view.ts with full message rendering, updated agents.ts with click-to-open navigation, modified message-stream.ts with optional per-session streaming.
</objective>

<execution_context>
@/Users/lucassenechal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lucassenechal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-conversation-view/27-RESEARCH.md
@.planning/phases/27-conversation-view/27-01-SUMMARY.md

# Source files
@ui/src/ui/views/agents.ts
@ui/src/ui/components/message-stream.ts
@ui/src/ui/components/typing-indicator.ts
@ui/src/ui/components/agent-avatar.ts
@ui/src/ui/state/metrics.ts
@ui/src/ui/state/agents.ts
@ui/src/ui/markdown.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conversation-view.ts, update message-stream.ts, and wire agents.ts</name>
  <files>
    ui/src/ui/views/conversation-view.ts
    ui/src/ui/components/message-stream.ts
    ui/src/ui/views/agents.ts
  </files>
  <action>
**A. Modify message-stream.ts -- Add optional streamText property:**

Add an optional `streamText` property to MessageStreamElement so it can accept per-session streaming text instead of always reading from the global `chatStream` signal:

```typescript
@property({ attribute: false }) streamText: string | null = null;
```

In the `render()` method, change the stream source to prefer `streamText` over `chatStream`:
```typescript
const stream = this.streamText ?? chatStream.get();
```

This is backward-compatible. When `streamText` is not set (null), it falls back to chatStream as before.

**B. Create ui/src/ui/views/conversation-view.ts -- Conversation view function:**

Create a pure render function `renderConversation(sessionKey: string, onBack: () => void)` that:

1. Imports:
   - `html, nothing, css` from "lit"
   - `unsafeHTML` from "lit/directives/unsafe-html.js"
   - `sessionConversations, sessionStreams` from "../state/metrics"
   - `agentSessions` from "../state/metrics"
   - `getAgentIdentity` from "../state/agents"
   - `toSanitizedMarkdownHtml` from "../markdown"
   - Side-effect imports: "../components/agent-avatar", "../components/typing-indicator", "../components/message-stream"

2. Reads signals at render time:
   - `const messages = sessionConversations.get().get(sessionKey) ?? []`
   - `const activeStream = sessionStreams.get().get(sessionKey)`
   - `const session = agentSessions.get().get(sessionKey)`

3. Renders a header bar with:
   - A back button (left arrow + "Back") that calls `onBack()`
   - Session info: agent name and task from session data
   - Session status badge (thinking/executing/complete/error) styled with appropriate colors

4. Renders a scrollable message container with:
   - Each message from `messages` array rendered as a message group:
     - `agent-avatar` on the left with the message's agentId resolved via `getAgentIdentity(msg.agentId)`
     - Agent name displayed above the bubble in small muted text with the identity's color
     - Message text rendered via `unsafeHTML(toSanitizedMarkdownHtml(msg.text))`
     - Timestamp in small muted text
   - Active streaming section (if `activeStream` exists):
     - `typing-indicator` with the streaming agent's identity
     - `message-stream` component with `.streamText=${activeStream.text}` and `.agentId=${activeStream.agentId}`

5. Auto-scroll behavior (implement directly in the view):
   - The message container div should have an id or class for scroll reference
   - Use a `@scroll` event handler on the container to track scroll position
   - Track `userScrolledUp` state: true when `scrollHeight - scrollTop - clientHeight > 50`
   - After each render, if `!userScrolledUp`, scroll to bottom using `requestAnimationFrame(() => container.scrollTop = container.scrollHeight)`
   - Show a "Scroll to bottom" button (fixed at bottom of container) when `userScrolledUp` is true, clicking it sets `userScrolledUp = false` and scrolls to bottom

   NOTE: Since this is a render function (not a LitElement), the scroll state needs to be managed via a module-level signal or closure. Use a module-level `selectedScrollLocked` signal (simple boolean signal) and bind the scroll handler. The auto-scroll after render can be triggered by the consuming component's `updated()` lifecycle.

   SIMPLIFICATION: For the render function approach, implement auto-scroll by adding a `scroll-anchor` div at the bottom of the messages container. The consuming LitElement (in agents.ts, which uses SignalWatcher) will handle the `updated()` callback. In the conversation-view, just include the scroll container with overflow-y auto and the anchor div. The agents.ts view can call `this.renderRoot?.querySelector('.conversation-scroll')?.scrollTo(...)` in its updated callback if needed.

   PRACTICAL APPROACH: Keep it simple. Add `overflow-y: auto` to the message container. Add a tiny div at the bottom as a scroll anchor. Use a module-level `userScrolledUp` variable (not signal, to avoid re-renders). Attach `@scroll` handler inline. After render, check the variable and auto-scroll if false. The conversation-view function returns HTML that includes `@scroll=${handleConversationScroll}` on the container and a "scroll to bottom" floating button when scrolled up.

6. Styling: Use inline styles or a `<style>` tag within the rendered HTML following existing patterns in the codebase (agents.ts uses inline styles). Key styles:
   - Container: `display:flex; flex-direction:column; height:100%`
   - Header: `display:flex; align-items:center; gap:12px; padding:12px 16px; border-bottom:1px solid rgba(255,255,255,0.1)`
   - Back button: `cursor:pointer; background:none; border:1px solid rgba(255,255,255,0.2); border-radius:8px; padding:6px 12px; color:inherit; font-size:0.85rem`
   - Messages scroll area: `flex:1; overflow-y:auto; padding:16px; display:flex; flex-direction:column; gap:16px`
   - Message group: `display:flex; gap:12px; align-items:flex-start`
   - Message bubble: `padding:10px 14px; border-radius:12px; border-bottom-left-radius:4px; background:var(--assistant-bubble-bg, #2d2d44); line-height:1.5; word-wrap:break-word; overflow-wrap:break-word; max-width:85%`
   - Agent name: `font-size:0.75rem; font-weight:600; margin-bottom:4px`
   - Timestamp: `font-size:0.65rem; opacity:0.5; margin-top:4px`
   - Status badge colors: thinking=#f59e0b, executing=#3b82f6, complete=#10b981, error=#ef4444
   - Markdown styling: pre/code blocks same as message-stream.ts (overflow-x:auto, border-radius:6px, background:rgba(0,0,0,0.3), padding:12px)
   - Scroll-to-bottom button: `position:sticky; bottom:8px; align-self:center; background:var(--assistant-bubble-bg, #2d2d44); border:1px solid rgba(255,255,255,0.2); border-radius:20px; padding:6px 16px; color:inherit; cursor:pointer; font-size:0.8rem; z-index:10`

7. Empty state: If no messages AND no activeStream, show a muted message: "No conversation data yet. Messages will appear as the agent generates responses."

**C. Update agents.ts -- Add session card click and conditional rendering:**

1. Add imports:
   - `import { signal } from "@lit-labs/signals"`
   - `import { renderConversation } from "./conversation-view"`

2. Add a module-level signal for selected session:
   ```typescript
   const selectedSession = signal<string | null>(null);
   ```

3. Modify `renderAgents()`:
   - At the top, check `const selected = selectedSession.get()`
   - If selected is not null, return `renderConversation(selected, () => selectedSession.set(null))` instead of the card grid
   - Add `@click` handler to each `agent-session-card`:
     ```typescript
     @click=${() => selectedSession.set(s.sessionKey)}
     ```
   - Add `style="cursor:pointer"` to each session card

This creates a simple toggle: card grid view (default) vs conversation view (when a session is selected). The back button in conversation view sets `selectedSession` back to null, returning to the card grid.
  </action>
  <verify>Run `pnpm build` from the project root. Verify no TypeScript errors. Read all three modified files to confirm:
1. message-stream.ts has `streamText` property and uses it in render()
2. conversation-view.ts exports renderConversation function
3. agents.ts imports renderConversation, has selectedSession signal, has click handler on cards, conditionally renders conversation view
  </verify>
  <done>
- Clicking a session card shows the conversation view for that session
- Conversation view displays completed messages with agent avatars, names, colors, and markdown
- Active streaming text displays via message-stream with the streamText property
- Typing indicator shows during active streaming
- Back button returns to session card grid
- Auto-scroll to newest content with scroll-up pause
- Empty state shown when no conversation data exists
- Build passes with no errors
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Full conversation view with live streaming, auto-scroll, markdown rendering, agent identity markers, and session card click navigation. Three files modified: message-stream.ts (streamText prop), conversation-view.ts (new), agents.ts (click + conditional render).</what-built>
  <how-to-verify>
1. Start the gateway and open the dashboard in browser
2. Navigate to the Agents tab
3. Trigger an agent session (or wait for one to appear)
4. Verify session cards appear with status indicators
5. Click a session card -- it should open the conversation view
6. Verify the conversation view shows:
   - Header with back button, agent name, task, status badge
   - Message bubbles with agent avatar, name (in agent's color), and markdown-rendered text
   - If streaming is active: typing indicator and streaming text with blinking cursor
   - Auto-scroll to newest content
7. Scroll up in the conversation -- auto-scroll should pause
8. Scroll back down or click "Scroll to bottom" -- auto-scroll should resume
9. Click the Back button -- should return to session card grid
10. Verify the existing Chat tab still works (message-stream backward compatibility)
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
1. `pnpm build` passes with no errors
2. Clicking session card opens conversation view
3. Messages render with agent identity (avatar, name, color)
4. Active streaming shows typing indicator and streaming text
5. Markdown and code blocks render properly
6. Auto-scroll works with scroll-up pause
7. Back button returns to card grid
8. Existing Chat tab is unaffected (message-stream backward compatible)
</verification>

<success_criteria>
- Users can click a session card and see a live conversation stream
- Each message bubble shows agent avatar, name, and color
- Active streaming displays with typing indicator and blinking cursor
- Markdown and code blocks render with syntax highlighting
- Auto-scroll to newest content, with scroll-up pause override
- Back button navigation works
- Existing Chat tab streaming is not broken
</success_criteria>

<output>
After completion, create `.planning/phases/27-conversation-view/27-02-SUMMARY.md`
</output>
